### 1、**static关键字的作用**

 

-  修饰局部变量

  static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）

-  修饰全局变量

  全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性。被static修饰的全局变量只能被该包含该定义的文件访问（即改变了作用域）。

-  修饰函数

   static修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。

-  修饰成员变量

   用static修饰类的数据成员使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持同一个实例。 因此，static成员必须在类外进行初始化(初始化格式：int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。

-  修饰成员函数

   用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问类的static成员变量。静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。例如可以封装某些算法，比如数学函数，如ln，sin，tan等等，这些函数本就没必要属于任何一个对象，所以从类上调用感觉更好，比如定义一个数学函数类Math，调用Math::sin(3.14);还可以实现某些特殊的设计模式：如Singleton；

最重要的特性：隐藏

  当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

不可以同时用const和static修饰成员函数。

### 2、const的使用：

定义
const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。

主要作用
1、可以定义const常量，具有不可变性
2、便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。例如： void f(const int i) { …} 编译器就会知道i是一个常量，不允许修改；
3、可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。
4、节省时间和提高效率，编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

```c
const int a;--//定义一个整型常量
int const a;--//定义一个整型常量
const int *a;--//定义一个常量指针，指针可变，指向常量
int * const a;--//定义一个指针常量，指针为常量，指向变量
int const * const a;--//定义一个指针为常量，指向常量

```

### 3.关键字volatile作用，以及常用场合。

告诉编译器不要随便优化我的代码，在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
常用场合：（在内核当中）

一个硬件寄存器
中断中用到的变量
线程之间共享变量

### 4.register关键字的含义和场合:

register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。

使用register修饰符有几点限制。

1.register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2.因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。
3.它和volatile是截然相反，所以对于一些可能被硬件修改的变量，谨慎使用。

### 5、解释堆和栈的区别

答：堆（heap）和栈(stack)的区别

（1）申请方式
stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间
heap:需要程序员自己申请，并指明大小，在c中malloc函数
如p1=(char*)malloc(10);
在C++中用new运算符
如p2=(char*)malloc(10);
但是注意p1、p2本身是在栈中的。

（2）申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

（3）申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

（4）申请效率的比较：
栈:由系统自动分配，速度较快。但程序员是无法控制的。
堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，他不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。

（5）堆和栈中的存储内容
栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

（6）存取效率的比较

char s1[]="aaaaaaaaaaaaaaa";
char *s2="bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

### 6、野指针

**1. 指针未初始化**：指针变量刚被创建时不会自动成为NULL指针，它的缺省值是**随机**的，**它所指的空间是随机的。**

**2. 指针越界访问**：指针指向的范围超出了合理范围，或者调用函数时返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

**3 .指针释放后未置空**：有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。其实它们只是把指针所指的内存给释放掉，但并**没有把指针本身忘记**。此时指针指向的就是**无效内存**。释放后的指针应立即将指针置为NULL，防止产生“野指针”。

### 7、关于结构体的的注意事项

为了实现高效的访问数据, 大多的处理器喜欢 (或强制要求) 多字节对象 (例如,结构中任何大于 char 的类型) 不能处于随意的内存地址, 而必须是 2 或 4 或对象大小的倍数。所以某些字节位置的数据就充当了 “填充”作用，都是为了保持结构中后面的域的对齐。我们姑且称这些只有一点点有用的字节为填充字节。

### 8、内存分区

栈区：由系统分配，使用时速度较快。

堆区：由用户申请和释放。

BSS段 未初始化全局变量，未初始化全局静态变量。
数据段 已初始化全局变量、已初始化全局静态变量、局部静态变量、常量数据。
代码段 可执行代码、字符串常量。

### 9、

```c
#include<stdio.h>  
void main()  
{  
    int a[5] = {1, 2, 3, 4, 5};  
    int *ptr = (int *)(&a + 1);  
    printf("%d, %d", *(a + 1), *(ptr - 1));  
}  

```

> 答案：输出为2, 5

> 解读： a是数组首元素地址，所以*(a + 1)就是第二个元素a[1]。&a是数组地址，所以&a +1是整个数组结尾的下一个地址，*(ptr - 1)就是a[4]。

### 10 联合体

联合体所有成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权。一个联合体变量的总长度应至少能容纳最大的成员变量，且需要进行内存补齐。

### 11、常见排序

插入排序、选择排序、冒泡排序、快速排序